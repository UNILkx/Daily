[toc]

## tips

- 输入输出数据规模较大($10^5$)时,使用$scanf$读取比$cin$更快，同样的，使用$printf$比$cout$输出也更快。对应的头文件为$<cstdio>$

- 一般用c的$printf$设置输出格式，如小数位数之类的。c++的cout设置小数输出的方法是这样的。
  头文件是$<iomanip>$，输出格式是$cout<<fixed<<setprecision(n)<<num$，即输出n位小数。

- $pow(e,x)$函数，可以求幂指数，也可以开根，但只能处理实数下的运算。开根示例$1.0/3$

  开根遇到$e$值为为负数时，求解结果是未知的。将e转换成绝对值可以运算。

- 模板$pair$ 基本用法 $pair<T,T> name$。$pair$是用来绑定两个相关的数据的，这和$struct$变量中有两个元素是相同的，只是在不愿意特地为此声明时可以使用$pair$

## 递归

“自己调用自己”

```c++
int dfs(int n){
	//边界处理
    if n逾界
        return ;
    //节点处理
    if(节点未加入){
        加入节点；
        输出保存；
        dfs(n+1);继续递归
        恢复现场
    }
}
```

递归无论是处理枚举还是排序，形成的递归思路都是一个**递归树**。

**我们需要处理的就是每个节点的抉择，以及递归停止条件，同时别忘记递归结束时，返回到原先节点需要恢复现场**

### 递归枚举

枚举，每个元素都有两种状态：选他和不选他，同时，递归进行到一定深度后，部分元素可能还没有被选择到。

所以，元素是有三种状态：还未选择，选他，不选他。

在递归进行时，无论是向左递归还是向右递归，都应该注意还原状态。

> 此时递归图类似于一个满二叉树。向左递归和向右递归决定是先输出大的还是小的。

### 递归排列

此时是节点分支逐渐减少的树。

## 递推



## 差分

以一维数组为例，数组可以用 $a[i]$ 独立表示出来，也能够按照这样的方式表达出来
$$
a[0],(a[0]+dir[1]),(a[0]+dir[1]+dir[2])......,(a[0]+...dir[n])
$$
其中 $dir[i]$ 我们称之为**差分数组**[^1]。此时数组的表示方式变成了**首元素+差分数组**来表示。对于数组的表示，差分数组并不优秀，但是涉及到连续的元素操作时，差分能很好的降低时间复杂度。

例如，对 $[l,s]$ 下标的元素统一加 $c$，普通数组是按照下表循环处理，时间复杂度是$O(n)$

差分数组只需要处理 $dir[l]$ 和 $dir[s+1]$ 修正相邻数组差值即可，时间复杂度是 $O(1)$.新的数组按照表达式求解即可

[^1]:$dir[i]=a[i]-a[i-1]$，代表数组相邻元素差值

## 前缀和

前缀和思路与差分相同。

不同在于，前缀和是统计前面所有元素的和，通过顺序遍历前缀和数组，相邻两项相减得到原始数组。

## 二分

二分包括:`二分查找`和`二分答案`

下面是二分查找的模板。向右查找和向左查找，在有序数组中的目的分别是：`找到第一个满足的元素`和`找到最后一个满足的元素`。这种情况一般出现在同一元素出现多次的情况。

### 两个模板

- 向右查找

  ```c++
  while(l<r){
  	mid=(l+r+1)>>1;
  	if(check(mid)) l=mid;
  	else r=mid-1;
  }
  ```

- 向左查找

  ```c++
  while(l<r){
  	mid=(l+r)>>1;
  	if(check(mid)) r=mid;
  	else l=mid+1;
  }
  ```

- 此外，还有浮点数的二分，此时写做

  ```c++
  while(r-l>1e-5){
  	double mid=(l+r)/2;
  	if(check(mid)) l=mid;
  	else r=mid;
      //此时两者可交换
  }
  ```

**一般而言，数组的下标都是从1开始的** （待实践

> 关于 **可能出现死循环的问题**  要注意除法都是向下取整。
>
> 当使用$mid=r+l>>1$时， 若取$l=mid$，则陷入死循环。
>
> 当使用$mid=r+l+1>>1$时，若取$r=mid$，则陷入死循环

## 快速幂

### 问题描述

对于 $a^b\mod{p}$ 的问题,当a、b、p很大的时候，我们寻求将时间复杂度压缩到 $O(logb)$​的算法。快速幂就是处理这个问题的。

### 解决过程

> 前提：`对于任何一个整数，都可以用二进制的方式表示`
>
> 推导：根据前提，有$b=(a_n a_{n-1} ...a_1 a_0)_2$ 从而幂指数可以表示为 $a^b=a^{2^{a_0}} \cdot a^{2^{a_1}}\cdot ...\cdot a^{2^{a_n}}$ 各项分别取模的过程中，不难发现，$a^{2^0} \% p=a \% p ,a^{2^1} \% p=(a^{2^0})^2 \% p,a^{2^2}\%p=(a^{2^1})^2 \% p$​
>
> 结论：根据推导，每一项的对p的模，都是前一项平方后对p取模

因此有以下模板

```c++
typedef long long ll;

ll qmi(int a,int b,int p){
    //p=1的时候结果都为0，加上对p取模更严谨
    int ans=1%p;
    while(b){
        //从低位开始检测,当为1时，此位需要取模
        if(b&1) ans= ans*a%p;
        //因为每一项模都是前一项平方后对p取模，所以每次迭代a都需要平方,最后需要取模防止溢出
        a=(ll)a*a%p;
        b=b>>1;
    }
    retrun ans;
}
```

## Nim博弈论

### 问题描述

有n堆石子，每堆分别有 $a_1,a_2,a_3.....a_n$个石头。两个人进行博弈，每次可从任意一堆石头中取出任意数量（必须大于0），两人均采用最优策略。当某人无法进行操作时，输。

### 解决过程

一般而言，两人博弈采用`跟随策略`即可作为最优解：即A拿x个石头，B也拿x个石头。

以两个石堆为例，分两种情况考虑（均A先手）

- 两石堆数量相同。此时A无论取多少，B从另一石堆取相同数量，最后必然A无法操作
- 两石堆数量不同。此时A可从`数量多的石堆中取出两个石堆的差值`，使问题变成情况1但B先手

可以逐步推导3个石堆，更多石堆。

这里直接给出结果

> 当n个石堆数量异或结果不为0，先手必胜；反之后手必胜。

给出一个不太严谨的推导过程：

多个石堆的问题是可以转化成两个石堆的问题的，所以用两个石堆的情况分析。

两个石堆一旦数量相同（异或为0），依据跟随策略，两人的操作相当于是对二进制同一位的两次减操作，最后该位仍然为0，从而导致先手必然会面对最后为0的情况，后手获胜；

而一旦数量不同（异或不为0），先手总可以把异或结果的二进制数为1的高位变为0（而后手后续无法对高位进行操作），从而将情况变成前一种，而先手变成后手，从而获胜。

综上，用异或是可行。

